//
//  MAPViewController.swift
//  mickey
//
//  Created by Varun Iyer on 5/11/19.
//  Copyright (c) 2019 Michelle Friedman. All rights reserved.
//
//  This file was generated by the 🐍 VIPER generator
//

import UIKit
import Mapbox
import SnapKit
import Pastel
import MapboxCoreNavigation
import MapboxNavigation
import MapboxDirections
import MapboxGeocoder

enum State {
    case collapsed
    case expanded
}

final class MAPViewController: UIViewController, SearchResultVCDelegate, UISearchResultsUpdating {

    // MARK: - Public properties -

    var presenter: MAPPresenterInterface!
    var externalAnimators: [UIViewPropertyAnimator] = []
    let disneyLandCoordinate = CLLocationCoordinate2D(latitude: 41.899719, longitude: -87.625122)
    
    private var navigateButton: UIButton!
    
    private var directionsRoute: Route?
    
    
    // MARK: - Private properties -
    
    private var shadowBackgroundView: RoundShadowView!
    private var pastelView: PastelView!
    private var globeImageView: UIImageView!
    private var mapView: NavigationMapView!

    
    
    private var myAnnotationView: MyAnnotationView!
    private var myLocation: CLLocation!
    private var locationManager: CLLocationManager!
    private var light: MGLLight!
    
    // Back Button
    private var backImageView: UIImageView!
    private var backPastelView: PastelView!
    
    // Gestures
    private var tapViewGesture: UITapGestureRecognizer!
    private var tapBackGesture: UITapGestureRecognizer!
    
    // Tracks all running aninmators
    private var progressWhenInterrupted: CGFloat = 0
    private var runningAnimators = [UIViewPropertyAnimator]()
    private var state: State = .collapsed
    private var animatorDuration = 0.75
    private var generator = UIImpactFeedbackGenerator(style: .heavy)
    
    var searchBackView: PastelView!

    
    /*lazy var bottomBlurView: UIVisualEffectView? = {

        let view = self.addBottomBlur()
        return view

    }()*/
    
    lazy var bottomBlurView: UIImageView? = {

        let view = self.bleandImageView()
        return view

    }()
    
    // MARK: - Lifecycle -

    override func viewDidLoad() {
        super.viewDidLoad()
        self.view.backgroundColor = .clear
        self.view.frame = CGRect(x: Constants.w/2 - 60/2, y: Constants.h - 82.0 - 60/2, width: 60, height: 60)
        
        _setupView()
        determineCurrentLocation() { (location) in
            self.mapView.setCenter(CLLocationCoordinate2D(latitude: location.coordinate.latitude, longitude: location.coordinate.longitude), zoomLevel: 5.5, animated: true)
        }
    }
    
    private func addButton(){
        navigateButton = UIButton(frame:CGRect(x: (view.frame.width/2) - 100, y: view.frame.height - 75, width: 200, height: 50))
        navigateButton.backgroundColor = UIColor.white
        navigateButton.setTitle("NAVIGATE", for: .normal)
        navigateButton.setTitleColor(UIColor(red: 59/255, green: 178/255, blue: 208/255, alpha: 1), for: .normal)
        navigateButton.titleLabel?.font = UIFont(name: "AvenirNext-DemiBold", size: 18)
        navigateButton.layer.cornerRadius = 25
        navigateButton.layer.shadowOffset = CGSize(width: 0, height: 10)
        navigateButton.layer.shadowRadius = 5
        navigateButton.layer.shadowOpacity = 0.3
        navigateButton.addTarget(self, action: #selector(navigateButtonWasPressed), for: .touchUpInside)
        view.addSubview(navigateButton)
    }
    
    
    @objc func navigateButtonWasPressed(_sender: UIButton){
        //mapView.setUserTrackingMode(.none, animated: true)
        mapView.setUserTrackingMode(.none, animated: true, completionHandler: nil)
        
        let annotation = MGLPointAnnotation()
        annotation.coordinate = disneyLandCoordinate
        annotation.title = "Start Navigation"
        mapView.addAnnotation(annotation)
        
        print(mapView.userLocation!.coordinate)
        
        calculateRoute(from: (mapView.userLocation!.coordinate), to: disneyLandCoordinate, annotation: annotation){(route, error) in
            if error != nil {
                print ("Error getting route")
            }
        }
    }
    
    func calculateRoute(from originCoor: CLLocationCoordinate2D, to destinationCoor: CLLocationCoordinate2D, annotation: MGLPointAnnotation, completion: @escaping(Route?, Error) -> Void){
        let origin = Waypoint(coordinate: originCoor, coordinateAccuracy: -1, name: "Start")
        let destination = Waypoint(coordinate: destinationCoor, coordinateAccuracy: -1, name: "Finish")
        let options = NavigationRouteOptions(waypoints: [origin, destination], profileIdentifier: .automobileAvoidingTraffic)
        
        _ = Directions.shared.calculate(options, completionHandler: { (waypoints, routes, error) in
            self.directionsRoute = routes?.first
            
            if let route = self.directionsRoute {
                
                self.drawRoute(route: route)
                
                self.mapView.selectAnnotation(annotation, animated: true, completionHandler: nil)

                let coordinateBounds = MGLCoordinateBounds(sw: destinationCoor, ne: originCoor)

                let insets = UIEdgeInsets(top: 50, left: 50, bottom: 50, right: 50)

                let routeCam = self.mapView.cameraThatFitsCoordinateBounds(coordinateBounds, edgePadding: insets)

                self.mapView.setCamera(routeCam, animated: true)
            }
        })
    }
    
    func drawRoute(route: Route){
        
        guard route.coordinateCount > 0 else {return}
        
        var routeCoordinates = route.coordinates!
        
        let polyline = MGLPolylineFeature(coordinates: &routeCoordinates, count: route.coordinateCount)
        
        if let source = mapView.style?.source(withIdentifier: "route-source") as? MGLShapeSource {
            source.shape = polyline
        } else {
            
            let source = MGLShapeSource(identifier: "route-source", features: [polyline], options: nil)
            
            let lineStyle = MGLLineStyleLayer(identifier: "route-style", source: source)
            lineStyle.lineColor = NSExpression(forConstantValue: UIColor(red:0.86, green:1.00, blue:0.00, alpha:0.7))
            
            lineStyle.lineWidth = NSExpression(forConstantValue: 7.0)
            lineStyle.lineCap = NSExpression(forConstantValue: "round")
            lineStyle.lineJoin = NSExpression(forConstantValue: "round")
            lineStyle.lineBlur = NSExpression(forConstantValue: 2.0)
            
            
            mapView.style?.addSource(source)
            
            mapView.style?.addLayer(lineStyle)
        }
    }
    
    
	
    override var prefersStatusBarHidden: Bool {
        return true
    }
    
    // MARK: View Setup
    
    private func _setupView() {
        // background view
        
        shadowBackgroundView = RoundShadowView(frame: CGRect(x: 0, y: 0, width: self.view.frame.width, height: self.view.frame.height), cornerRadius: 60/2, shadowRadius: 3, shadowOffset: CGSize(width: 0.0, height: 1.0), shadowOpacity: 0.9)
        shadowBackgroundView.backgroundColor = .white
        shadowBackgroundView.layer.cornerRadius = 60/2
        
        view.addSubview(shadowBackgroundView)
        
        // pastel view
        
        pastelView = PastelView(frame: shadowBackgroundView.frame)
        pastelView.layer.cornerRadius = 60/2
        pastelView.clipsToBounds = true
        
        pastelView.startPastelPoint = .left
        pastelView.endPastelPoint = .right
        
        // Custom Duration
        pastelView.animationDuration = 2
        
        // Custom Color
        pastelView.setColors([UIColor(red:0.00, green:0.03, blue:0.09, alpha:1.0),
        UIColor(red: 37/255, green: 235/255, blue: 239/255, alpha: 0.75)])
        view.addSubview(pastelView)
        pastelView.startAnimation()
        
        // globe
        
        globeImageView = UIImageView(image: UIImage(named: "atlasGlobe"))
        globeImageView.contentMode = .scaleAspectFit
        
        view.addSubview(globeImageView)
        globeImageView.snp.makeConstraints { (make) in
            make.centerX.equalTo(self.shadowBackgroundView.snp.centerX)
            make.centerY.equalTo(self.shadowBackgroundView.snp.centerY)
            make.width.equalTo(45)
            make.height.equalTo(45)
        }
        
        // map view
        
        let url = URL(string: "mapbox://styles/cephalopod004/ck65tq3pj16zb1itfxex5x2sf")
        // light mode: mapbox://styles/spottiyer/cjvfgbn2u16z51fo3hm3i198r
        // dark mode : mapbox://styles/spottiyer/cjvfghaxj618h1fmv5mq94so7
        mapView = NavigationMapView(frame: CGRect(x: 0, y: 0, width: self.view.frame.width, height: self.view.frame.height), styleURL: url)
        mapView.layer.cornerRadius = 50
        mapView.delegate = self
        mapView.alpha = 0
        
        setupMapView()
        
        view.addSubview(mapView)
       
        // tap gesture
        tapViewGesture = UITapGestureRecognizer(target: self, action: #selector(tapViewActionHandler))
        self.view.addGestureRecognizer(tapViewGesture)
        
        searchBackView = PastelView(frame: CGRect(x: 0, y: 0, width: 0, height: 0))
        searchBackView.startPastelPoint = .left
        searchBackView.endPastelPoint = .right
        
        searchBackView.animationDuration = 3.0
        
        searchBackView.setColors([UIColor(red: 37/255, green: 235/255, blue: 239/255, alpha: 0.85), UIColor(red: 225/255, green: 247/255, blue: 248/255, alpha: 1.0)])
        
        searchBackView.startAnimation()
        self.view.addSubview(searchBackView)
    }
    
    private func setupMapView() {
        mapView.isZoomEnabled = true
        mapView.isScrollEnabled = true
        mapView.compassView.isHidden = false
        mapView.center = view.center
        mapView.logoView.isHidden = true
        mapView.attributionButton.isHidden = true
        mapView.showsUserLocation = true
        mapView.isUserInteractionEnabled = true
        mapView.setUserTrackingMode(.follow, animated: true)
        
        //update annotations
        updateMonumentAnnotations(monuments: presenter.getMonuments())
    }
    
    private func _setupBackButton() {
        // pastel view
        
        backPastelView = PastelView(frame: CGRect(x: Constants.w/2 - 60/2, y: Constants.h - 82.0 - 60/2, width: 60, height: 60))
        backPastelView.layer.cornerRadius = 50/2
        backPastelView.clipsToBounds = true
        
        backPastelView.startPastelPoint = .left
        backPastelView.endPastelPoint = .right
        
        // Custom Duration
        backPastelView.animationDuration = 2
        
        // Custom Color
        backPastelView.setColors([UIColor(red:0.00, green:0.03, blue:0.09, alpha:1.0),
                              UIColor(red: 37/255, green: 235/255, blue: 239/255, alpha: 0.75)])
        
        let bottomColor = UIColor(displayP3Red:41/255, green: 146/255, blue: 141/255, alpha: 1).cgColor
        let topColor = UIColor(red:0.00, green:0.03, blue:0.09, alpha:1.0).cgColor
        view.addSubview(backPastelView)
        backPastelView.alpha = 0
        
        backImageView = UIImageView(image: UIImage(named: "atlasCamera"))
        backImageView.contentMode = .scaleAspectFit
        backImageView.alpha = 0
        
        // tap back gesture
        tapBackGesture = UITapGestureRecognizer(target: self, action: #selector(tapViewActionHandler))
        backPastelView.addGestureRecognizer(tapBackGesture)
        
        view.addSubview(backPastelView)
        
        view.addSubview(backImageView)
        backImageView.snp.makeConstraints { (make) in
            make.width.equalTo(45)
            make.height.equalTo(45)
            make.centerX.equalTo(self.backPastelView.snp.centerX)
            make.centerY.equalTo(self.backPastelView.snp.centerY)
        }
    }
    
    // MARK: Location Setup
    
    private func determineCurrentLocation(_ completion: @escaping (CLLocation) -> Void) {
        if locationManager == nil {
            createLocationManager()
        }
        
        while locationManager.location == nil {
            
        }
        
        myLocation = locationManager.location
        
        completion(myLocation)
    }
    
    private func createLocationManager() {
        locationManager = CLLocationManager()
        setupLocationManager()
    }
    
    private func setupLocationManager() {
        locationManager.delegate = self
        locationManager.requestAlwaysAuthorization()
        locationManager.desiredAccuracy = kCLLocationAccuracyBest
        locationManager.allowsBackgroundLocationUpdates = true
        
        if CLLocationManager.locationServicesEnabled() {
            locationManager.startUpdatingLocation()
        }
    }
    
    // MARK: Actions
    
    @objc func tapViewActionHandler() {
        if state == .collapsed {
            self.tapExpand()
            self.bottomBlurView?.isHidden = false
        } else {
            self.bottomBlurView?.isHidden = true
            self.tapCollapse()
        }
    }
    
    // MARK: Utility
    
    private func expandedFrame() -> CGRect {
        return CGRect(x: 0, y: 0, width: Constants.w, height: Constants.h)
    }
    
    private func collapsedFrame() -> CGRect {
        return CGRect(x: Constants.w/2 - 60/2, y: Constants.h - 82.0 - 60/2, width: 60, height: 60)
    }
    
    private func fractionComplete(state: State, translation: CGPoint) -> CGFloat {
        let translationY = state == .expanded ? -translation.y : translation.y
        return translationY / ((Constants.h - 60) - self.view.frame.minY) + progressWhenInterrupted
    }
    
    private func nextState() -> State {
        switch self.state {
        case .collapsed:
            return .expanded
        case .expanded:
            return .collapsed
        }
    }
    
    // MARK: Gesture
    
    private func handleTapGesture(_ recognizer: UITapGestureRecognizer) {
        self.animateOrReverseRunningTransition(state: self.nextState(), duration: TimeInterval(animatorDuration))
        
        for animator in externalAnimators {
            animator.startAnimation()
            
            animator.addCompletion { _ in
                if self.externalAnimators.firstIndex(of: animator) != nil {
                    self.externalAnimators.remove(at: self.externalAnimators.firstIndex(of: animator)!)
                }
            }
        }
    }
    
    // MARK: Animations
    
    private func mapViewEntranceAnimation() {
        let animator = UIViewPropertyAnimator(duration: 0.5, curve: .easeIn) {
            self.mapView.alpha = 1
            self.pastelView.alpha = 0
            self.mapView.layer.cornerRadius = 0
            self.pastelView.layer.cornerRadius = 0
            self.shadowBackgroundView.layer.cornerRadius = 0
            
            var topPadding: CGFloat? = 0
            if #available(iOS 11.0, *) {
                let window = UIApplication.shared.keyWindow
                topPadding = window?.safeAreaInsets.top
            }
            self.searchBackView.frame = CGRect(x: 0, y: 0, width: Constants.w, height: 60 + (topPadding ?? 0))
            self.searchBackView.alpha = 1
        }
        
        let d = myLocation.distance(from: CLLocation(latitude: mapView.centerCoordinate.latitude, longitude: mapView.centerCoordinate.longitude))
        
        let distance = Double.random(in: 2000...2500)
        let pitch = 0.0
        let heading = 0.0
        let camera = MGLMapCamera(lookingAtCenter: myLocation.coordinate, acrossDistance: distance, pitch: CGFloat(pitch), heading: heading)
        let duration = max(log(d/600), 1)
        mapView.fly(to: camera, withDuration: duration, completionHandler: nil)
        
        animator.addCompletion { _ in
            self._setupBackButton()
            self.backButtonEntranceAnimation()
            //self.addButton()
        }
        
        animator.startAnimation()
    }
    
    private func backButtonEntranceAnimation() {
        let animator = UIViewPropertyAnimator(duration: 0.5, curve: .easeIn) {
            self.backPastelView.alpha = 1
            self.backImageView.alpha = 1
        }
        
        animator.startAnimation()
        backPastelView.startAnimation()
    }
    
    private func addFrameAnimator(state: State, duration: TimeInterval) {
        let frameAnimator = UIViewPropertyAnimator(duration: duration, dampingRatio: 1) {
            switch state {
            case .expanded:
                self.view.frame = self.expandedFrame()
                self.mapView.frame = self.expandedFrame()
                self.shadowBackgroundView.frame = self.expandedFrame()
                self.shadowBackgroundView.layer.cornerRadius = 50
                self.pastelView.frame = self.expandedFrame()
                self.pastelView.layer.cornerRadius = 50
            case .collapsed:
                self.view.frame = self.collapsedFrame()
                self.shadowBackgroundView.frame = CGRect(x: 0, y: 0, width: self.view.frame.width, height: self.view.frame.height)
                self.pastelView.frame = CGRect(x: 0, y: 0, width: self.view.frame.width, height: self.view.frame.height)
                self.mapView.frame = CGRect(x: 0, y: 0, width: self.view.frame.width, height: self.view.frame.height)
                self.mapView.alpha = 0
                self.pastelView.alpha = 1
                self.mapView.layer.cornerRadius = 50
                self.shadowBackgroundView.layer.cornerRadius = 60/2
                self.pastelView.layer.cornerRadius = 60/2
                self.backImageView.alpha = 0
                self.backPastelView.alpha = 0
                
                self.searchBackView.frame = CGRect(x: 0, y: 0, width: 0, height: 0)
                self.searchBackView.alpha = 0
            }
        }
        
        frameAnimator.addCompletion { (position) in
            switch position {
            case .end:
                self.state = self.nextState()
            default:
                break
            }
            self.runningAnimators.removeAll()
            
            if self.state == .expanded {
                self.mapViewEntranceAnimation()
                self.view.removeGestureRecognizer(self.tapViewGesture)
            } else if self.state == .collapsed {
                self.view.addGestureRecognizer(self.tapViewGesture)
                self.backImageView.removeFromSuperview()
                self.backPastelView.removeFromSuperview()
                self.mapView.frame = self.collapsedFrame()
            }
        }
        
        runningAnimators.append(frameAnimator)
    }
    
    // MARK: Gesture Animation Sync
    
    private func animateTransitionIfNeeded(state: State, duration: TimeInterval) {
        if runningAnimators.isEmpty {
            self.addFrameAnimator(state: state, duration: duration)
        }
    }
    
    private func animateOrReverseRunningTransition(state: State, duration: TimeInterval) {
        if runningAnimators.isEmpty {
            animateTransitionIfNeeded(state: state, duration: duration)
            runningAnimators.forEach({ $0.startAnimation() })
        } else {
            runningAnimators.forEach({ $0.isReversed = !$0.isReversed })
        }
    }
    
    private func startInteractiveTransition(state: State, duration: TimeInterval) {
        self.animateTransitionIfNeeded(state: state, duration: duration)
        runningAnimators.forEach({ $0.pauseAnimation() })
        progressWhenInterrupted = runningAnimators.first?.fractionComplete ?? 0
    }
    
    private func updateInteractiveTransition(fractionComplete: CGFloat) {
        runningAnimators.forEach({ $0.fractionComplete = fractionComplete })
    }
    
    private func continueInteractiveTransition(fractionComplete: CGFloat) {
        let cancel: Bool = fractionComplete < 0.2
        
        if cancel {
            runningAnimators.forEach({
                $0.isReversed = !$0.isReversed
                $0.continueAnimation(withTimingParameters: nil, durationFactor: 0)
            })
            return
        }
        
        let timing = UICubicTimingParameters(animationCurve: .easeOut)
        runningAnimators.forEach({ $0.continueAnimation(withTimingParameters: timing, durationFactor: 0)})
    }
    
    
    
    func placeMarkSelected(placeMark: GeocodedPlacemark) {
        
        self.navigationItem.searchController?.isActive = false

        if let cordinate = placeMark.location?.coordinate {
            //let camera = MGLMapCamera(lookingAtCenter: cordinate, fromDistance: 4500, pitch: 15, heading: 180)
            //let camera = MGLMapCamera(lookingAtCenter: cordinate, acrossDistance: 3000, pitch: 15, heading: 18)
            //self.mapView.fly(to: camera, withDuration: 0.5, peakAltitude: 3000, completionHandler: nil)
            
            if let annotations = mapView.annotations {
                for annotation in annotations {
                    mapView.removeAnnotation(annotation)
                }
            }
            
            mapView.setUserTrackingMode(.none, animated: true, completionHandler: nil)
            
            let annotation = MGLPointAnnotation()
            annotation.coordinate = cordinate
            annotation.title = "Click to Navigate"
            mapView.addAnnotation(annotation)
            
            print(mapView.userLocation!.coordinate)
            
            calculateRoute(from: (mapView.userLocation!.coordinate), to: cordinate, annotation: annotation){(route, error) in
                print (error)
            }
        }
    }
    
    func updateSearchResults(for searchController: UISearchController) {
                
            let vc = searchController.searchResultsController as! SearchResultVC
            
            guard var searchString = searchController.searchBar.text else {
                return
            }

            searchString = searchString.trimmingCharacters(in: .whitespaces)

            if searchString.isEmpty {return}
            vc.searchText = searchString

            if searchString.count > 1 {
                
                let options = ForwardGeocodeOptions(query: searchString)
                
                // To refine the search, you can set various properties on the options object.
                // options.allowedISOCountryCodes = ["US"]
                // options.focalLocation = CLLocation(latitude: 45.3, longitude: -66.1)
                
                options.maximumResultCount = 10
                
    //            if let countryCode = (Locale.current as NSLocale).object(forKey: .countryCode) as? String {
    //                print(countryCode)
    //                // options.allowedISOCountryCodes = [countryCode]
    //            }
    //
                if let cordinate = mapView.userLocation?.coordinate {
                    options.focalLocation = CLLocation(latitude: cordinate.latitude, longitude: cordinate.longitude)
                }
                
                options.allowedScopes = [.address, .all]
                
                Geocoder.shared.geocode(options) { (placemarks, attribution, error) in
                    
                    if let arr = placemarks {
                         vc.arrResults =  arr
                         vc.tableView.reloadData()
                    }
                }
                
            } else {
                vc.tableView.reloadData()
            }
        }
}

// MARK: - Extensions -

extension MAPViewController: MAPViewInterface {
    func tapExpand() {
        self.navigationController?.setNavigationBarHidden(false, animated: true)
        self.generator.impactOccurred()
        updateMonumentAnnotations(monuments: presenter.getMonuments())
        handleTapGesture(tapViewGesture)
    }
    
    func tapCollapse() {
        self.navigationController?.setNavigationBarHidden(true, animated: true)
        self.generator.impactOccurred()
        handleTapGesture(tapViewGesture)
    }
    
    func updateMonumentAnnotations(monuments: [Monument]) {
        if mapView != nil {
            if mapView.annotations != nil {
                for annotation in mapView.annotations! {
                    if let mapAnnotation = annotation as? MapAnnotation {
                        if mapAnnotation.type == 0 {
                            mapView.removeAnnotation(annotation)
                        }
                    }
                }
            }
            
            for monument in monuments {
                let point = MapAnnotation()
                point.coordinate = CLLocationCoordinate2D(latitude: monument.latitude, longitude: monument.longitude)
                point.title = monument.name
                point.monument = monument
                point.type = 0
                mapView.addAnnotation(point)
            }
        }
    }
    
    func updateFriendAnnotations(friends: [User]) {
        if mapView != nil
        {
            if mapView.annotations != nil {
                for annotation in mapView.annotations! {
                    if let mapAnnotation = annotation as? MapAnnotation {
                        if mapAnnotation.type == 0 {
                            mapView.removeAnnotation(annotation)
                        }
                    }
                }
            }
            
            for friend in friends {
                let point = MapAnnotation()
                point.coordinate = CLLocationCoordinate2D(latitude: friend.latitude, longitude: friend.longitude)
                point.title = friend.firstName
                point.friend = friend
                point.type = 1
                mapView.addAnnotation(point)
            }
        }
    }
    
    func setCamera(latitude: Double, longitude: Double) {
        if !(mapView.centerCoordinate.latitude == latitude && mapView.centerCoordinate.longitude == longitude) {
            let d = CLLocation(latitude: mapView.centerCoordinate.latitude, longitude: mapView.centerCoordinate.longitude).distance(from: CLLocation(latitude: latitude, longitude: longitude))
            
            let distance = Double.random(in: 300...700)
            let pitch = Float.random(in: 40...60)
            let heading = 0.0
            let camera = MGLMapCamera(lookingAtCenter: CLLocationCoordinate2D(latitude: latitude, longitude: longitude), acrossDistance: distance, pitch: CGFloat(pitch), heading: heading)
            let duration = max(log(d/600), 1)
            mapView.fly(to: camera, withDuration: duration, completionHandler: nil)
        }
    }
}

extension MAPViewController: MGLMapViewDelegate {
    func mapView(_ mapView: MGLMapView, viewFor annotation: MGLAnnotation) -> MGLAnnotationView? {
        
        if annotation is MGLUserLocation && mapView.userLocation != nil {
            self.myAnnotationView = MyAnnotationView()
            return self.myAnnotationView
        }
        
        if annotation.isKind(of: MapAnnotation.self) && (annotation as! MapAnnotation).type == 0 {
            let view = MonumentAnnotationView(reuseIdentifier: "monumentAnnotation", monument: (annotation as! MapAnnotation).monument)
            return view
        }
        
        
        return nil
    }
    
    func mapView(_ mapView: MGLMapView, annotationCanShowCallout annotation: MGLAnnotation) -> Bool {
        // Always allow callouts to popup when annotations are tapped.
       return true
    }
    
    func mapView(_ mapView: MGLMapView, tapOnCalloutFor annotation: MGLAnnotation) {
        
        
        let styles = [CustomDayStyle()]
        
        let url = URL(string: "mapbox://styles/spottiyer/cjvfgbn2u16z51fo3hm3i198r")
        if let route = directionsRoute {
            let navigationVC = NavigationViewController(for: route, styles: styles)
            present(navigationVC, animated: true, completion: nil)
        }
    }
    

    
    func mapView(_ mapView: MGLMapView, calloutViewFor annotation: MGLAnnotation) -> MGLCalloutView? {
        0
      
        
        //return MeCalloutView(representedObject: annotation, map: self)
        return nil
    }
    
    /*func mapView(_ mapView: MGLMapView, didFinishLoading style: MGLStyle) {
        
        // Add a MGLFillExtrusionStyleLayer.
        addFillExtrusionLayer(style: style)
        
        // Create an MGLLight object.
        light = MGLLight()
        
        // Create an MGLSphericalPosition and set the radial, azimuthal, and polar values.
        // Radial : Distance from the center of the base of an object to its light. Takes a CGFloat.
        // Azimuthal : Position of the light relative to its anchor. Takes a CLLocationDirection.
        // Polar : The height of the light. Takes a CLLocationDirection.
        let position = MGLSphericalPositionMake(5, 180, 80)
        light.position = NSExpression(forConstantValue: NSValue(mglSphericalPosition: position))
        
        // Set the light anchor to the map and add the light object to the map view's style. The light anchor can be the viewport (or rotates with the viewport) or the map (rotates with the map). To make the viewport the anchor, replace `map` with `viewport`.
        light.anchor = NSExpression(forConstantValue: "map")
        style.light = light
    }
    
    func addFillExtrusionLayer(style: MGLStyle) {
        // Access the Mapbox Streets source and use it to create a `MGLFillExtrusionStyleLayer`. The source identifier is `composite`. Use the `sources` property on a style to verify source identifiers.
        let source = style.source(withIdentifier: "composite")!
        let layer = MGLFillExtrusionStyleLayer(identifier: "extrusion-layer", source: source)
        layer.sourceLayerIdentifier = "building"
        layer.fillExtrusionBase = NSExpression(forKeyPath: "min_height")
        layer.fillExtrusionHeight = NSExpression(forKeyPath: "height")
        layer.fillExtrusionOpacity = NSExpression(forConstantValue: 0.4)
        layer.fillExtrusionColor = NSExpression(forConstantValue: UIColor.white)
        
        // Access the map's layer with the identifier "poi-scalerank3" and insert the fill extrusion layer below it.
        let symbolLayer = style.layer(withIdentifier: "poi-scalerank3")!
        style.insertLayer(layer, below: symbolLayer)*/
//    }
}

extension MAPViewController: CLLocationManagerDelegate {
    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {

        guard let mostRecentLocation = locations.last else {
            return
        }
        myLocation = mostRecentLocation
    }
}
class CustomDayStyle: DayStyle {
    
    required init() {
        super.init()
        mapStyleURL = URL(string: "mapbox://styles/cephalopod004/ck65tq3pj16zb1itfxex5x2sf")!
    }
    
    override func apply() {
        super.apply()
       
    }
}
